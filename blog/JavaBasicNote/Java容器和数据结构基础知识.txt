java集合分类
    Collection接口
        list:Vector,LinkedList,ArrayList,CopyOnWriteArrayList
        Set:HashSet,LinkedHashSet,TreeSet
    Map接口
        HashMap,LinkedHashMap,TreeMap,ConcurrentHashMap

要记住的简单结论
    1)如果是集合类型，有List和Set供我们选择，List的特点是插入有序，元素可重复的，Set的特点是插入无序，元素不可重复
        至于选择哪个实现类来作为我们的存储容器，我们就得看具体的应用场景，是希望可重复就得用List下常见的子类
        是希望不可重复就选择Set下常见的子类
    2)如果是key-value型，那我们会选择Map，如果要保持插入顺序的，我们可以选择LinkedHashMap,
        如果不需要则选择HashMap,如果需要排序则选择TreeMap，如果需要线程安全则选择concurrentHashMap

java中数组和集合的区别
    1)长度的区别
        数组的长度固定，集合的长度可变
    2)元素的数据类型
        数组可以存储基本数据类型，也可以存储引用类型
        集合只能存储引用类型(你存储的是简单的int，它会自动装箱成Integer)

List集合
    List集合基础：
        1)实现了Collection接口
        2)List接口特性：有序(插入顺序和输出顺序一致),元素是可重复
        3)允许元素为null
    常用的子类
        ArrayList:底层数据结构是数组，线程不安全
        LinkedList:底层数据结构是链表，线程不安全
        Vector:底层数据结构是数组，线程安全

        ArrayList
            1)初始容量是10，此后每次扩容是原来容量的1.5倍，
                底层使用Arrays.copyof()方法扩容。而在该方法中使用的是System.arraycopy()方法进行扩容的，
                这个方法由native关键字标注，由C/C++编写
            2)ArrayList是基于动态数组实现的，在增删时候，需要数组的拷贝复制
            3)删除元素时不会减少容量，若希望减少容量则调用trimToSize()
            4)它不是线程安全的，它能存放null值

        Vector
            1)Vector底层也是数组，与ArrayList最大的区别就是同步(线程安全)，方法使用synchronized关键字标识
            2)在要求非同步的情况下，我们一般都是用ArrayList代替Vector
                如果想要ArrayList实现同步，可以使用Collections的方法：
                List<Object> list = Collections.synchronizedList(new ArrayList<>());
            3)另外，ArrayList在底层数组不够用时，在原来的基础上扩展0.5倍，Vector是扩展1倍

        LinkedList
            1)LinkedList底层是双向链表，双向链表方便从后往前遍历
            2)LinkedList实现了Deque接口，因此，我们可以操作linkedLists像操作队列和栈一样

        总结：查询多用ArrayList,增删多用LinkedList
            ArrayList增删慢并不是绝对的，
                如果增加元素一直使用add方法，即增加在末尾，那ArrayList要快
                如果一直删除末尾的元素也是ArrayList要快，因为不用复制移动位置

Set集合
    Set集合基础
        1)实现了Collection接口
        2)Set集合特性：无序的，元素不可重复
        3)底层大多数是Map结构的实现
        4)常用的三个子类都是非同步的
    常用的子类
        HashSet:
            1)底层数据结构是哈希表(是一个元素为链表的数组)+[红黑树]
            2)实际上就是封装了HashMap
            3)元素无序，可以为null
        LinkedHashSet:
            1)底层数据结构由哈希表+双向链表+[红黑树]
            2)父类是HashSet
            3)实际上是LinkedHashMap
            4)元素可以为null
        TreeSet:
            1)底层实际上是一个TreeMap实例(红黑树,一个平衡二叉树)
            2)可以实现排序功能
            3)元素不能为null
            4)TreeSet的排序方式和TreeMap排序方式一样。

Map集合
    Map集合基础
        1)Map集合的特点：将键映射到值的对象，一个映射不能包含重复的键，每个键最多只能映射到一个值
        2)Map和Collection集合的区别
            - Map集合存储元素是成对出现的，Map的键是唯一的，值是可以重复的
            - Collection集合存储元素是单独出现的，Collection的儿子Set集合中的元素是唯一的，List是可重复的
        要点：
            - Map集合的数据结构针对键有效，跟值无关
            - Collection集合的数据结构针对元素有效
    常用的子类
        HashMap:
            1)底层是哈希表(散列表)+[红黑树]，初始容量为16，装载因子为0.75，
                当装载因子*初始化容量小于散列表元素时，该散列表就会再次散列，扩容2倍。
                装载因子大了，虽然减小了散列表再散列次数，但是却增加了散列冲突的概率
                装载因子小了，虽然减小了散列冲突的概率，但同时扩容(再散列)的次数也相应增加。
                初始容量过大，那么遍历元素时的速度就会受到影响
                初始容量过小，再散列次数可能会变多，扩容也是非常消耗性能的。
            2)允许为null，存储无序
            3)非同步
            4)散列表容量大于64且链表大于8时，转成红黑树
            5)如果hashCode相同，key不同则替换元素，否则就是散列冲突
            6)hashMap中并不是直接拿key的哈希值存储元素，而是将key的哈希值与该哈希值的高16位做异或操作，增加随机性，减小哈希冲突的概率
            7)HashMap的key如果是自定义类对象，则该类对象需要重写hashCode方法和equals方法。
        LinkedHashMap:
            1)底层是哈希表+双向链表+[红黑树]，父类是HashMap
            2)允许为null，插入有序
            3)非同步
            4)LinkedHashMap遍历的是内部维护的双向链表，所以初始容量对LinkedHashMap遍历影响不大
            5)LinkedHashMap可以设置两种遍历顺序：访问顺序和插入顺序，默认是插入顺序，
                对于访问顺序，它是LRU(最近最少使用，页面置换算法中一种)算法
        TreeMap:
            1)底层是红黑树，保证了时间复杂度log(n)
            2)可以对其进行排序，使用Comparator比较器对象或者内部的Comparable的compareTo方法
            3)只有compare或者compareTo认定该元素相等，那就相等
            4)非同步
            5)自然排序(手动排序),元素不能为null
            6)TreeMap内部的comparator变量如果为null，则使用自然顺序排序，例如，直接new TreeMap(),就是使用自然排序
                自然排序(comparable接口,key中自带的，例如Integer类实现了comparable接口)和比较器排序(comparator比较器排序接口)　
                元素有序，不是指存取顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法
                1)new HashMap():使用自然排序，默认是按键值的升序排序，根据key元素的compareTo方法来排序
                    当用Iterator遍历TreeMap时，得到的结果是排序后的。
                    例如：
                        TreeMap<Integer, Object> treeMap = new TreeMap<>();
                        treeMap.put(5,"5");
                        treeMap.put(3,"3");
                        treeMap.put(1,"1");
                        treeMap.put(2,"2");
                        treeMap.put(4,"4");
                        Set<Map.Entry<Integer, Object>> entries = treeMap.entrySet();
                        for(Map.Entry<Integer, Object> entry:entries){
                            System.out.println(entry.getKey()+":"+entry.getValue());
                        }
                        输出结果是：1,2,3,4,5，key值的升序排序
                2)new TreeMap(Comparator comparator):根据指定的比较器进行排序
                    在TreeMap带参构造器中创建一个匿名内部类对象，是comparator比较器的对象，然后重写compare方法
                    例如：
                        TreeMap<Integer, Object> treeMap = new TreeMap<>(new Comparator<Integer>() {
                            @Override
                            public int compare(Integer o1, Integer o2) {
                                return o1-o2;
                            }
                        });
                        treeMap.put(5,"5");
                        treeMap.put(3,"3");
                        treeMap.put(1,"1");
                        treeMap.put(2,"2");
                        treeMap.put(4,"4");
                        Set<Map.Entry<Integer, Object>> entries = treeMap.entrySet();
                        for(Map.Entry<Integer, Object> entry:entries){
                            System.out.println(entry.getKey()+":"+entry.getValue());
                        }
                        输出结果:1,2,3,4,5，key值的升序排序，
                        compare方法中o1-o2则按key值的升序排序，如果是o2-o1则按key值的降序排序。
        ConcurrentHashMap:
            1)底层是散列表+红黑树，支持高并发操作
            2)key和value都不能为null
            3)线程是安全的，利用CAS算法和部分操作(方法)上锁实现
            4)get方法是非阻塞，无锁的，重写Node类，通过volatile修饰nxt来实现每次获取都是最新设置的值

Collection接口下的线程安全容器：
    我们可能会想到Vector类，这个类确实是线程安全的容器，不过它的每个方法都加了synchronized,导致效率非常低
    我们可能会想到使用Collections包装下ArrayList或者HashSet等容器，但是实际上包装后的容器也几乎在其每个方法
    都加上了synchronized关键字，只不过它不是在方法声明处加的，而是方法内部加的，其加锁粒度比Vector小，更好点
    不过JUC为我们提供了更好的选择，
        在Map中提供了ConcurrentHashMap,
        在list集合中为我们提供了CopyOnWriteArrayList
        在Set集合中为我们提供了CopyOnWriteArraySet，其实就是CopyOnWriteArrayList，可以在构造方法看到
    CopyOnWrite容器的缺点：
        1)内存占用，如果CopyOnWriteArrayList经常要增删改里面的数据，经常执行add(),set(),remove()方法的话，那会比较耗费内存
        2)数据的一致性，CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。

java中HashTable和ConcurrentHashMap的区别
    HashTable是在每一个方法上都加了Synchronized完成同步，效率低下
    ConcurrentHashMap通过在部分方法加锁和利用CAS算法来实现同步的。

java中HashTable与HashMap的区别
    HashTable不允许元素为null,且该类是同步的，
    HashMap允许元素为null,且HashMap是非同步的。
        要想使的HashMap同步，可以使用：Map<Object, Object> map = Collections.synchronizedMap(new HashMap<>());
        或者直接使用ConcurrentHashMap,HashTable已经过时了。
    除此之外，HashTable和HashMap都相同，数据结构都是数组链表(Entry数组，Entry本身是链表)的结构，采用链表法解决hash冲突问题


部分数据结构知识点
    数据结构：数据的组织方式
    数据结构的分类
        1)线性表
            1.1)数组(动态数组):存储同一种类型的多个元素的容器，有索引，方便我们的获取
                特点：查询快，增删慢
            1.2)栈(先进后出)
            1.3)队列(先进先出)
                普通队列
                阻塞队列
                并发队列
                双端队列
            1.4)链表：由一个链子把多个结点连起组成的数据
                单链表：由数据和一个地址组成(数据域和一个指针域组成)
                    特点：查询慢(找任意元素都是从头元素开始)，增删快
                双向循环链表：双向链表和循环链表的结合
                双向链表：如果每个结点由三部分组成，上一个元素的地址，数据，下一个元素的地址，则就可以组成双向链表
                循环链表：头元素的地址给了最后一个元素的地址位置，就是循环链表
        2)散列表
            基础知识：
                装填因子:装填因子决定何时对散列表进行再散列,默认0.75，如果表中超过75%的位置已经填入了元素，
                则建立一个是原来两倍大小的散列表，将原来表中的元素重新散列到新表中。
            2.1)散列函数:决定每个元素映射到数组中不同位置的映射规则，被称为散列函数，通过这个函数可以知道元素存放的位置
            2.2)冲突解决：两个不同的元素根据散列函数映射到了同一个位置，被称为散列冲突
                链表法：在冲突的位置放置一个链表的表头，将冲突的多个元素放在链表中
                开放寻址：如果发生冲突，则重新再找另一个可用的位置，但此方式会占据其他位置，导致数据聚集，使得此后每个元素都可能经过多次尝试才能解决冲突
                其他
            2.3)位图
            2.4)动态扩容
        3)树
            基础知识
                树的高度，深度算的是结点之间的边
                树的深度：是由根结点出发，到叶子结点的最长路径长度，从上往下数，根结点深度为0
                树的高度：从叶子结点到根结点:从下往上数，叶子结点高度为0
                结点深度：根结点到这个结点经历的边的条数(从根结点往下数到目标结点，根结点深度为0，以此类推)
                结点高度：这个结点到叶子结点要经历最多的边数(从结点往下数，叶子结点高度为0)

                结点的度：对于一个结点，所拥有子树的个数，被称为该结点的度
                整树的度：对于一棵树，树内各个结点度的最大值就是树的度
                结点的层次：从一棵树根结点起，根结点所在层为第一层，根的子节点所在层为第二层，以此类推
                搜索方式分为深度优先算法和广度优先算法
                    深度优先算法
                        先序遍历：输出：父节点->左节点->右结点
                        中序遍历：输出：左节点->父节点->右结点
                        后序遍历：输出：左节点->右节点->父节点
                    广度优先算法：从根结点一次按深度遍历各个结点
            3.1)二叉树
                二叉树基本性质：
                    1)二叉树第i层上的结点数目最多为2^(i-1)(i>=1)
                    2)深度为k的二叉树至多有(2^k)-1个结点(k>=1)
                    3)包含n个结点的二叉树的高度至少为log2n(向下取整)+1，或者log2(n-1)(向上取整)(每层有最多结点，2结点的情况)
                        高度最大为n(每层只要一个结点的情况)
                    ...
                两个特别的二叉树
                    满二叉树：除了叶子结点外，每一个结点都有左子节点和右子结点
                    完全二叉树：除最后一层结点外，其他层结点都必须要有两个子节点，并且最后一层结点都要左排列(左子树)
                    满二叉树肯定是完全二叉树，完全二叉树不一定是满二叉树
                二叉查找树，也叫二分查找树，二叉搜索树
                    特点：每个结点的值大于该结点的左子节点，小于右子节点
                平衡二叉树：如果二叉树的树形接近直线，则会变成线性搜索，就和单链表一样，搜索效率将变的非常差。
                    二叉查找树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率，所以
                    平衡二叉树的特点：各个结点的左右子树的高度相差不超过1
                平衡二叉查找树(AVL树-最早的平衡二叉树，红黑树)
                    将以上两种树的特点结合起来就是平衡二叉查找树，默认情况下，平衡二叉树就是平衡二叉查找树
                    AVL树
                        AVL平衡二叉树的失衡与调整
                            1)最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小失衡子树
                                也就是说，一个失衡的树，是有可能有多颗子树同时失衡的，这个时候只需调整最小的不平衡子树，就能将不平衡的树
                                调整为平衡的树
                            2)平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的，根据旋转的方向有两种处理方式：左旋，右旋
                            3)左旋操作
                                3.1)结点的右孩子替代此结点的位置
                                3.2)右孩子的左子树变为该结点的右子树
                                3.3)结点本身变为右孩子的左子树
                            4)右旋操作
                                4.1)结点的左孩子替代此结点的位置
                                4.2)左孩子的右子树变为该结点的左子树
                                4.3)结点本身变为左孩子的右子树
                            5)四种插入结点的情况会导致AVL平衡二叉树失衡
                                5.1)插入方式LL，描述：在A结点的左子树根结点的左子树上插入结点而破坏平衡，旋转方式：右旋转
                                5.2)插入方式RR，描述：在A结点的右子树根结点的右子树上插入结点而破坏平衡，旋转方式：左旋转
                                5.3)插入方式LR，描述：在A结点的左子树根结点的右子树上插入结点而破坏平衡，旋转方式：先左旋再右旋
                                    旋转使得原来根结点的左孩子的右孩子作为新的根结点
                                5.4)插入方式RL，描述：在A结点的右子树根结点的左子树上插入结点而破坏平衡，旋转方式：先右旋再左旋
                                    旋转使得原来根结点的右孩子的左孩子作为新的根结点
                        AVL平衡二叉树的四种删除结点方式
                            AVL树和二叉查找树的删除操作情况一致，都分为四种情况：
                            1)删除叶子结点
                            2)删除的结点只有左子树
                            3)删除的结点只有右子树
                            4)删除的结点既有左子树又有右子树
                            只不过AVL树在删除结点后需要重新检查平衡性并修正，同时删除操作和插入操作后的平衡修正区别在于：
                            插入操作后只需要对第一个最小失衡子树结点进行修正，而删除操作需要修正树中所有非平衡结点。
                    红黑树
                        为什么有了AVL树还需要红黑树？
                            因为AVL树严格遵照其平衡性质，导致在删除，插入结点时，都需要进行大量的修正操作(左旋，右旋)
                            在那种插入，删除很频繁的场景中，使得查询效率的回报远远达不到付出。所以产生红黑树
                        红黑树的特点：
                            1)具有二叉查找树的特点
                            2)根结点是黑色的
                            3)每个叶子结点都是黑色的空结点(NIL),也就是说叶子结点不存数据
                            4)如果一个结点为红色，则其孩子结点必为黑色，也就是说，红色结点是被黑色结点隔开的
                            5)从任一结点到其后代叶子的路径上，均包含相同数目的黑色结点
                        红黑树的性质：最长路径长度不超过最短路径长度的2倍
                        红黑树的应用：java中的TreeSet,TreeMap,HashMap
                        与平衡二叉树AVL不同的是，红黑树在插入，删除等操作，不会像AVL那样，不会频繁调整修正树的平衡性
                        其代价是牺牲一部分的查询性能，所以，单论查询，AVL查询性能高于红黑树。
                完全二叉树
                    除最后一层结点外，其他层结点都必须要有两个子节点，并且最后一层结点都要左排列(左子树)
            3.2)多路查找树
                B树
                    定义：B树是一颗多路平衡查找树，我们描述一个B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点
                        一般用m表示阶数，当m取2时，就是我们常见的二叉搜索树，m为3时是2-3树
                        m阶的B树最多有m个孩子结点
                    性质：
                        1)每个结点最多有m-1个关键字
                        2)根结点最少可以只有1个关键子
                        3)非根结点至少有Math.ceil(m/2)-1个关键字(数据)，Math.ceil(m/2)含义是向上取整
                            例如Math.ceil(4.5)=5
                        4)每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中所有关键字都小于它，
                            而右子树中的所有关键字都大于它。
                        5)所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。
                    注意：m阶数越大，树的高度越低，但m并不能无限制，如果m无限制，则B树会退化成有序数组。
                    B树应用场景：文件系统，数据库索引
                    为什么文件系统，数据库索引不用红黑树或有序数组呢？
                        答：因为文件系统和数据库索引都是存放在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。
                        所以要使用多路的B树，每次加载B树的一个结点，然后一步一步找。
                        如果在内存中，红黑树比B树效率更高，但是涉及到磁盘操作，B树就更优了
                B+树
                    B+树是在B树的基础上进行改造，它的数据都在叶子结点，同时叶子结点之间还加了指针形成链表
                    为什么数据库中B+树使用的最多？
                        因为select查询数据时，不一定会只选择一条，有时候会选多条，如果是多条的话，
                        B树需要做局部的中序遍历，可能要跨层访问，而B+树由于所有数据都在叶子结点，不用跨层
                        而且因为有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了
                2-3树
                    2-3树产生的原因：
                        二叉搜索树(BST)在最好的情况下搜索的时间复杂度为O(logn)，但如果插入结点时，插入元素序列
                        本身就是有序的，树的形状就成了一个链表形式，时间复杂度就会变成O(n)。由此产生平衡二叉树(AVL)
                        AVL要求，树中各结点的平衡因子不能大于1，使得树形更加分化，降低了树的高度，但是AVL树在插入删除结点后
                        需要保持树的平衡性，需要进行大量平衡修正操作，可能导致AVL树平衡带来的搜索性能提升不足为了平衡树所带来的性能消耗
                        所以引入2-3树提升效率，2-3树本质上也是一种平衡搜索树，但2-3树已经不是一颗二叉树了，因为2-3树允许存在3这种结点
                        3-结点中可以存放2个元素，并且可以有三个子结点
                    2-3树定义：
                        1)2-3树要么为空要么具有以下性质：
                        2)对于2-结点，和普通二叉搜索树结点一样，有一个数据域和两个子结点指针，两个子结点要么为空，要么也是一个2-3树
                            当前结点的数据的值大于左子树中所有结点的数据，小于右子树中所有结点的数据
                        3)对于3-结点，有两个数据域a,b和三个子结点指针，该结点左子树中所有结点的数据要小于a，右子树中所有结点数据大于b
                            中子树中所有结点数据在a到b之间，大于a,小于b。
                2-3-4树
            3.3)堆
                小顶堆
                大顶堆
                二项堆
                优先队列
                斐波那契堆
        4)图
            4.1)图的存储
                邻接矩阵
                邻接表
            4.2)关键路径
            4.3)最小生成树
            4.4)最短路径
            4.5)拓扑排序



